var documenterSearchIndex = {"docs":
[{"location":"api/TestImages/#Test-images","page":"Test images","title":"Test images","text":"","category":"section"},{"location":"api/TestImages/","page":"Test images","title":"Test images","text":"Modules = [MartaCT.TestImages]","category":"page"},{"location":"api/TestImages/#MartaCT.TestImages.ImageParams","page":"Test images","title":"MartaCT.TestImages.ImageParams","text":"struct ImageParams{T<:Real}\n\nHold information to construct the input test image.\n\n\n\n\n\n","category":"type"},{"location":"api/TestImages/#MartaCT.TestImages.ImageParams-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Test images","title":"MartaCT.TestImages.ImageParams","text":"ImageParams([T=Float32]; <keyword arguments>) where {T<:Real}\n\nConstruct ImageParams object.\n\nArguments:\n\nwidth=200: width of the rectangle gray scale image.\nheight=40: height of the rectangle gray scale image.\npad=30: padding around image.\ndist=10: distance between images.\nradius=20: radius of calibration circle.\ngray_scale=0..1: interval of gray scale values.\ncalibration_value=nothing: value of the calibration circle. If not specified, is gray_scale[2].\n\n\n\n\n\n","category":"method"},{"location":"api/TestImages/#MartaCT.TestImages.background_position","page":"Test images","title":"MartaCT.TestImages.background_position","text":"background_position(imp::AbstractImageParams)\n\nReturn suitable position to calibrate background.\n\n\n\n\n\n","category":"function"},{"location":"api/TestImages/#MartaCT.TestImages.calibration_position","page":"Test images","title":"MartaCT.TestImages.calibration_position","text":"calibration_position(imp::AbstractImageParams)\n\nGet the position for calibration (max value).\n\n\n\n\n\n","category":"function"},{"location":"api/TestImages/#MartaCT.TestImages.circle_image","page":"Test images","title":"MartaCT.TestImages.circle_image","text":"circle_image(imp::AbstractImageParams)\n\nCreate a square image with a circle of given value from parameters imp.\n\n\n\n\n\n","category":"function"},{"location":"api/TestImages/#MartaCT.TestImages.circle_image-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Test images","title":"MartaCT.TestImages.circle_image","text":"circle_image([T=Float32]; radius=20, value=1) where {T<:Real}\n\nCreate a square image with a circle of given value.\n\nExamples\n\njulia> circle_image(30, 0.8)\n30×30 Array{Float32,2}:\n[...]\n\nSee also: gray_scale_image, combine_images\n\n\n\n\n\n","category":"method"},{"location":"api/TestImages/#MartaCT.TestImages.circle_polar_image-Union{Tuple{T}, Tuple{Type{T},Integer,Integer,Integer}} where T<:Real","page":"Test images","title":"MartaCT.TestImages.circle_polar_image","text":"circle_polar_image([T=Float32] nr, nϕ, radius; value=1) where {T<:Real}\n\nCreate a circle of radius radius inside a nr×nϕ image in polar coordinates .\n\nExamples\n\njulia> circle_polar_image(30, 30, 10)\n30×30 Array{Float32,2}:\n[...]\n\n\n\n\n\n","category":"method"},{"location":"api/TestImages/#MartaCT.TestImages.circle_position","page":"Test images","title":"MartaCT.TestImages.circle_position","text":"circle_position(imp::AbstractImageParams)\n\nReturn circle position inside image given image parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/TestImages/#MartaCT.TestImages.combine_images-Union{Tuple{T}, Tuple{ImageParams{T},AbstractArray{T,2},AbstractArray{T,2}}} where T<:Real","page":"Test images","title":"MartaCT.TestImages.combine_images","text":"combine_images(imp::ImageParams{T}, rect::AbstractMatrix{T}, circle::AbstractMatrix{T}) where {T <: Real}\n\nHelper function to create a gray scale image.\n\nCombine the rect image with the circle image for calibration. The circle image should be smaller than the gray scale image!\n\nSee also: gray_scale_image, circle_image\n\n\n\n\n\n","category":"method"},{"location":"api/TestImages/#MartaCT.TestImages.create_image-Tuple{ImageParams}","page":"Test images","title":"MartaCT.TestImages.create_image","text":"create_image(par::ImageParams)\n\nCreate gray scale image.\n\n\n\n\n\n","category":"method"},{"location":"api/TestImages/#MartaCT.TestImages.create_pyramid_image-Tuple{ImageParams}","page":"Test images","title":"MartaCT.TestImages.create_pyramid_image","text":"create_pyramid_image(par::ImageParams)\n\nCreate pyramid gray scale image.\n\n\n\n\n\n","category":"method"},{"location":"api/TestImages/#MartaCT.TestImages.gray_scale_image-Union{Tuple{ImageParams{T}}, Tuple{T}} where T<:Real","page":"Test images","title":"MartaCT.TestImages.gray_scale_image","text":"gray_scale_image(imp::ImageParams)\n\nCreate an image with a gray scale rectangle with given scale gray_scale from parameters imp.\n\n\n\n\n\n","category":"method"},{"location":"api/TestImages/#MartaCT.TestImages.gray_scale_image-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Test images","title":"MartaCT.TestImages.gray_scale_image","text":"gray_scale_image(\n    [T=Float32];\n    rows=40,\n    cols=200,\n    swidth=nothing,\n    sheight=nothing,\n    gray_scale=-1000..1000,\n) where {T <: Real}\n\nCreate an image with a gray scale rectangle with given scale gray_scale.\n\nExamples\n\njulia> gray_scale_image(swidth=80, sheight=40, gray_scale=-1000..1000)\n40×80 Array{Float32,2}:\n[...]\n\nSee also: circle_image, combine_images\n\n\n\n\n\n","category":"method"},{"location":"api/TestImages/#MartaCT.TestImages.gray_scale_indices-Tuple{ImageParams}","page":"Test images","title":"MartaCT.TestImages.gray_scale_indices","text":"gray_scale_indices(imp::ImageParams)\n\nReturn a tuple (row, column_range) where row is the row index of the scale and column_range is the range of columns.\n\n\n\n\n\n","category":"method"},{"location":"api/TestImages/#MartaCT.TestImages.pyramid_gray_scale_image-Union{Tuple{ImageParams{T}}, Tuple{T}} where T<:Real","page":"Test images","title":"MartaCT.TestImages.pyramid_gray_scale_image","text":"pyramid_gray_scale_image(imp::ImageParams)\n\nCreate an image with a pyramid gray scale rectangle with given scale gray_scale from parameters imp.\n\nCreate an image with a pyramid gray scale rectangle with given scale gray_scale from parameters imp.\n\n\n\n\n\n","category":"method"},{"location":"api/TestImages/#MartaCT.TestImages.pyramid_gray_scale_image-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"Test images","title":"MartaCT.TestImages.pyramid_gray_scale_image","text":"pyramidgrayscaleimage([T=Float32]; swidth=200, sheight=40, grayscale=-1000..1000, plateau = 0) where {T <: Real}\n\nCreate an image with a pyramid gray scale rectangle with given scale gray_scale.\n\nExamples\n\njulia> pyramid_gray_scale_image(swidth=80, sheight=40, gray_scale=-1000..1000)\n40×80 Array{Float32,2}:\n[...]\n\nSee also: gray_scale_image, circle_image, combine_images\n\n\n\n\n\n","category":"method"},{"location":"api/TestImages/#MartaCT.TestImages.square_image-Union{Tuple{T}, Tuple{Type{T},Integer,Integer}, Tuple{Type{T},Integer,Integer,Union{Nothing, Integer}}} where T<:Real","page":"Test images","title":"MartaCT.TestImages.square_image","text":"square_image([T=Float32] r, c; l=nothing) where {T<:Real}\n\nCreate a l×l square inside a r×c image.\n\nExamples\n\njulia> square_image(30, 30; l=10)\n30×30 Array{Float32,2}:\n[...]\n\n\n\n\n\n","category":"method"},{"location":"api/TestImages/#MartaCT.TestImages.square_position-Tuple{MartaCT.TestImages.SquareParams}","page":"Test images","title":"MartaCT.TestImages.square_position","text":"square_position(imp::SquareParams)\n\nReturn square position inside image given image parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Applicative/#Applicative","page":"Applicative","title":"Applicative","text":"","category":"section"},{"location":"api/Applicative/","page":"Applicative","title":"Applicative","text":"Modules = [MartaCT.Applicative]","category":"page"},{"location":"api/Monads/#Monads","page":"Monads","title":"Monads","text":"","category":"section"},{"location":"api/Monads/","page":"Monads","title":"Monads","text":"Modules = [MartaCT.Monads]","category":"page"},{"location":"api/Algorithms/#Algorithms-documentation","page":"Algorithms documentation","title":"Algorithms documentation","text":"","category":"section"},{"location":"api/Algorithms/","page":"Algorithms documentation","title":"Algorithms documentation","text":"Modules = [MartaCT.AbstractAlgorithms, MartaCT.RadonAlgorithm]","category":"page"},{"location":"api/Algorithms/#MartaCT.AbstractAlgorithms.iradon","page":"Algorithms documentation","title":"MartaCT.AbstractAlgorithms.iradon","text":"iradon(sinog::AbstractMatrix, xs[, ys[, algorithm::AbstractProjectionAlgorithm[, coo::AbstractCoordinates]]]; <keyword arguments>)\n\nCompute the inverse Radon transform of sinog on the points given by the vectors xs and ys. If ys is omitted, the reconstruction is performed on the square with xs == ys. The default reconstruction algorithm is FBP. Please refer to the respective documentation for additional parameters.\n\nSee Also: reconstruct_image\n\n\n\n\n\n","category":"function"},{"location":"api/Algorithms/#MartaCT.AbstractAlgorithms.iradon-Tuple{AbstractArray{T,2} where T,AbstractParallelBeamGeometry,AbstractReconstructionAlgorithm}","page":"Algorithms documentation","title":"MartaCT.AbstractAlgorithms.iradon","text":"iradon(sinog::AbstractMatrix[, geometry::AbstractGeometry[, params::AbstractParams[, algorithm::AbstractProjectionAlgorithm]]]; <keyword arguments>)\n\nCompute the inverse Radon transform of sinog with explicit geometry. If the algorithm needs specific parameters, these can be passed with params. Additional parameters can be passed to the algorithm through keyword arguments. Please see the respective documentation for more details. The default algorithm is FBP.\n\nSee Also: reconstruct_image\n\n\n\n\n\n","category":"method"},{"location":"api/Algorithms/#MartaCT.AbstractAlgorithms.iradon-Tuple{AbstractArray{T,2} where T,AbstractReconstructionAlgorithm}","page":"Algorithms documentation","title":"MartaCT.AbstractAlgorithms.iradon","text":"iradon(sinog::AbstractMatrix[, algorithm::AbstractProjectionAlgorithm]; <keyword arguments>)\n\nCompute the inverse Radon transform of sinog with parameters given as keyword arguments. The parameters depend on the algorithm, please see the relative documentation. The default algorithm is FBP.\n\nSee Also: reconstruct_image\n\n\n\n\n\n","category":"method"},{"location":"api/Algorithms/#MartaCT.AbstractAlgorithms.radon","page":"Algorithms documentation","title":"MartaCT.AbstractAlgorithms.radon","text":"radon(image::AbstractMatrix, geometry::AbstractGeometry[, algorithm::AbstractProjectionAlgorithm]; <keyword arguments>)\n\nCompute the Radon transform of image with explicit geometry. Additional parameters can be passed to the algorithm through keyword arguments. Please see the relative documentation. The default algorithm is Radon.\n\nSee Also: project_image\n\n\n\n\n\n","category":"function"},{"location":"api/Algorithms/#MartaCT.AbstractAlgorithms.radon-2","page":"Algorithms documentation","title":"MartaCT.AbstractAlgorithms.radon","text":"radon(image::AbstractMatrix[, algorithm::AbstractProjectionAlgorithm]; <keyword arguments>)\n\nCompute the Radon transform of image with parameters given as keyword arguments. The parameters depend on the algorithm, please see the relative documentation. The default algorithm is Radon.\n\nSee Also: project_image\n\n\n\n\n\n","category":"function"},{"location":"api/Algorithms/#MartaCT.AbstractAlgorithms.radon-3","page":"Algorithms documentation","title":"MartaCT.AbstractAlgorithms.radon","text":"radon(image::AbstractMatrix, ts, ϕs[, algorithm::AbstractProjectionAlgorithm]; <keyword arguments>)\n\nCompute the Radon transform of image with integration points given by the vector ts and projection angles given by the vector ϕs. Additional parameters can be passed to the algorithm through keyword arguments.Please see the relative documentation. The default algorithm is Radon.\n\nSee Also: project_image\n\n\n\n\n\n","category":"function"},{"location":"api/Algorithms/#MartaCT.RadonAlgorithm.radon_diag","page":"Algorithms documentation","title":"MartaCT.RadonAlgorithm.radon_diag","text":"radon_diag(image::AbstractMatrix, ts::AbstractVector, ϕs::AbstractVector; <keyword arguments>)\n\nCompute the Radon transform of image inside a circle of radius hypot(rows,cols)/2 where rows and cols are the dimensions of image.\n\nSee Also: radon_square\n\n\n\n\n\n","category":"function"},{"location":"api/Algorithms/#MartaCT.RadonAlgorithm.radon_square","page":"Algorithms documentation","title":"MartaCT.RadonAlgorithm.radon_square","text":"radon_square(image::AbstractMatrix, ts::AbstractVector, ϕs::AbstractVector; <keyword arguments>)\n\nCompute the Radon transform of image inside the circle contained in the square of side min(rows,cols) where rows and cols are the dimensions of image.\n\nSee also: radon_default\n\n\n\n\n\n","category":"function"},{"location":"api/Simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"api/Simulations/","page":"Simulations","title":"Simulations","text":"Modules = [MartaCT.Simulations]","category":"page"},{"location":"api/Simulations/#MartaCT.Simulations.generate_photons-Tuple{Integer,Integer,Integer}","page":"Simulations","title":"MartaCT.Simulations.generate_photons","text":"generate_photons(n::Integer, nx::Integer, nϕ::Integer)\n\nGenerate n Poisson distributed photons per projection angle over an array of nx detectors.\n\nReturn a nd × nϕ matrix with the generated photons. ```\n\n\n\n\n\n","category":"method"},{"location":"api/Simulations/#MartaCT.Simulations.sample_sinogram_external-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T<:Real","page":"Simulations","title":"MartaCT.Simulations.sample_sinogram_external","text":"sample_sinogram_external(sinog::AbstractMatrix{T}; <keyword arguments>) where {T <: Real}\n\nSimulate a low dose CT scan. This Resample sinog with n photons.\n\nArguments\n\nsinog: sinogram data.\nsinog_path='_tmp_sinog.dat': path to a file where to write the sinogram to.\nresampled_path='_tmp_resampled.dat': path to a file where to read the resampled sinogram from.\nn=10000: mean number of photons.\nϵ=1: detectors quantum efficiency.\ntake_log=true: whether to take the logarithm of the resampled intensities to obtain the corresponding sinogram.\nverbosity=0: set verbosity level.\nprogress=false: show progress bar.\noptions=[]: Additional options to be passed to the program.\n\n\n\n\n\n","category":"method"},{"location":"api/Simulations/#MartaCT.Simulations.simulate_ct-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T<:Real","page":"Simulations","title":"MartaCT.Simulations.simulate_ct","text":"simulate_ct(sinog::AbstractMatrix{T}; <keyword arguments>) where {T <: Real}\n\nSimulate a low dose CT scan. This samples sinog with n random photons per projection angle.\n\nArguments\n\nsinog: sinogram data.\nnphotons::Integer=10000: mean number of photons.\nϵ::Real=1: detectors quantum efficiency.\ntake_log::Bool=true: whether to take the logarithm of the resampled intensities to obtain the corresponding sinogram.\n\n\n\n\n\n","category":"method"},{"location":"api/Simulations/#StatsBase.sample-Tuple{CTSinogram,AbstractArray{T,1} where T}","page":"Simulations","title":"StatsBase.sample","text":"StatsBase.sample(data::CTSinogram, xs::AbstractVector[; nsamples=1000, nblks=1, nbins=nothing])\n\nCompute nsamples from xs according to the distribution given by each column of data. Optionally, if nblks > 1, nblks × nsamples samples are computed. The sampled data are collected into a histogram of length nbins for each column in data. The resulting data have size (nbins, size(data, 2), nblks).\n\n\n\n\n\n","category":"method"},{"location":"QuantumOptics/#Quantum-Optics-example","page":"Quantum Optics","title":"Quantum Optics example","text":"","category":"section"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"ENV[\"GKS_WSTYPE\"] = \"svg\"\nusing MartaCT, Plots, QuantumOptics, IntervalSets, LinearAlgebra, Plots.Measures\ngr()\nPlots.reset_defaults()\ndefault(size=(500,300), rightmargin=0.5cm)","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"MartaCT can also be used for Quantum Tomography as the basic filtered backprojection algorithm can be used to reconstruct a quantum state (or more precisely the Wigner function) from the measurements of the position.","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"First we need to import the packages for this example. We use the QuantumOptics Julia package for the definition of the quantum objects.","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"using MartaCT, Plots, QuantumOptics, IntervalSets, LinearAlgebra","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"At this point, let's construct an optical cat state:","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"N = 64 # density matrix dimension\nα = 5\nbs = FockBasis(N-1)\nν = inv(√(2*(1+exp(-2abs2(α)))))\nψ = ν * (coherentstate(bs, α) + coherentstate(bs, -α))\nρ = ψ ⊗ ψ'\n@show tr(ρ)\nnothing # hide","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"bar(diag(ρ.data)|>real; c=:red, leg=:none)\nsavefig(\"rho-diag.svg\"); nothing # hide","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"(Image: )","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"We need to get the Wigner function representation in order to compute the marginal distributions of the position.","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"ζ = 10\nxs = linspace(-ζ..ζ, 200)\nW = wigner(ρ, xs, xs) |> permutedims |> CTTomogram\nδW = 4ζ^2 / length(W)\n@show sum(W) * δW\nheatmap(xs, xs, W)\nsavefig(\"Wcat.svg\"); nothing # hide","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"(Image: )","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"The marginal distributions can be computed as a Radon transform of the Wigner function:","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"ϕs = linspace(ORI(0..2π), 800)\nmarg = radon(W, xs, ϕs, RadonSquare())\n@show sum(marg[:,1])\nheatmap(ϕs, xs, marg)\nsavefig(\"marg.svg\"); nothing # hide","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"(Image: )","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"Now we can employ the standard FBP algorithm to recover the Wigner distribution:","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"Wrec = iradon(marg, xs, xs, FBPFFTSquare())\nheatmap(xs, xs, Wrec)\nsavefig(\"Wrec.svg\"); nothing # hide","category":"page"},{"location":"QuantumOptics/","page":"Quantum Optics","title":"Quantum Optics","text":"(Image: )","category":"page"},{"location":"Tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"ENV[\"GKS_WSTYPE\"] = \"svg\"\nusing MartaCT, Plots, Plots.Measures, IntervalSets\ngr()\nPlots.reset_defaults()\nPlots.default(size=(500,300), rightmargin=1cm, color=:grays)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's see a brief example on how MartaCT can be used.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"As a starting point we prepare the session importing some packages:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"using MartaCT, Plots, IntervalSets","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can generate our first image from the available test images (see Test Images) for a full list of test images.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"img = GrayScalePyramid()\npbg = ParallelBeamGeometry(img, nϕ=800)\nnothing # hide","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"We can plot the image as","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"heatmap(img)\nsavefig(\"img.svg\"); nothing # hide","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"which produces the image below.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The gray scale values of the image are in Hounsfield units, typically used in medical applications. In this case, where the image is just used to test the algorithm, there is, of course, no meaning in the actual values. We use this scale by default so that it can be used to compare with standard imaging procedures.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can compute the sinogram of img using the function project_image:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"sinog = project_image(img, RadonInfo(pbg), progress=false, rescaled=true)\nheatmap(sinog)\nsavefig(\"sinog.svg\"); nothing # hide","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"One can also use the low level function radon.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The reconstruction of the image can be done using the function reconstruct_image or the low level function iradon:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"tomog = reconstruct_image(sinog, FBPInfo(pbg), progress=false)\nheatmap(tomog)\nsavefig(\"tomog.svg\"); nothing # hide","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we can see that the final scale is not recovered properly: we need to calibrate the image! MartaCT provides a convenient framework for image calibration and analysis. Since we are studying a well defined image, MartaCT knows how to calibrate the resulting image according to the original image. In the general case, this would require to provide at least two ROIs (regions of interest) which are used to calibrate the final image.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"We can just do the following","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"calibrate_tomogram!(tomog, img; window=-1000..1000)\nheatmap(tomog)\nsavefig(\"tomog_calib.svg\"); nothing # hide","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"obtaining the final result","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The window keyword argument can be used to apply a window filter on the image so that the final interval of values specified through window are displayed.","category":"page"},{"location":"api/Interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"api/Interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [MartaCT.Interpolation]","category":"page"},{"location":"api/Info/#Info-objects","page":"Info objects","title":"Info objects","text":"","category":"section"},{"location":"api/Info/","page":"Info objects","title":"Info objects","text":"Modules = [MartaCT.Info]","category":"page"},{"location":"api/Geometry/#Geometry","page":"Geometry","title":"Geometry","text":"","category":"section"},{"location":"api/Geometry/","page":"Geometry","title":"Geometry","text":"Modules = [MartaCT.Geometry, MartaCT.FanBeam]","category":"page"},{"location":"api/Geometry/#MartaCT.Geometry.FanBeamGeometry-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}, Tuple{Type{T},AbstractTomograph}} where T<:Real","page":"Geometry","title":"MartaCT.Geometry.FanBeamGeometry","text":"FanBeamGeometry([T=Float32]; <keyword arguments>) where {T<:Real}\n\nCreate a new FanBeamGeometry object with given parameters.\n\nIt is assumed that the detectors are arranged on a circle arc, not flat.\n\nArguments\n\n`nϕ: number of scan angles.\nnd=nothing: number of detectors.\nrows=nothing: number of rows in the reconstructed image.\ncols=nothing: number of columns in the reconstructed image.\nwidth=nothing: alias for cols.\nheight=nothing: alias for rows.\nD: focal spot to ISO distance.\nD′=nothing: focal spot to detectors distance; if not specified   and also γ is not specified, is defined so that the total   fan angle is 1 radian.\nγ=nothing: total fan angle in degrees.\nδ=1: detectors spacing (cell size).\nα=360: scan angle in degrees.\nα₀=0: scan starting angle in degrees.\ncenter=nothing: virtual center channel, defaults to (nd-1)/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Geometry/#MartaCT.Geometry.ParallelBeamGeometry-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}, Tuple{Type{T},AbstractTomograph}} where T<:Real","page":"Geometry","title":"MartaCT.Geometry.ParallelBeamGeometry","text":"ParallelBeamGeometry([T=Float32]; <keyword arguments>) where {T<:Real}\n\nConstruct geometry for the simulation.\n\nArguments\n\nnϕ: number of projections.\nnd=nothing: number of detectors. If not specified, same as nϕ.\nrows=nothing: number of rows in the reconstructed image. If not specified, same as nd.\ncols=nothing: number of columns in the reconstructed image. If not specified, same as rows.\nwidth=nothing: alias for cols.\nheight=nothing: alias for rows.\nα=360: scan angle in degrees.\nα₀=0: starting scan angle in degrees.\ncenter=nothing: virtual center channel, defaults to (nd-1)/2.\n\n\n\n\n\n","category":"method"},{"location":"api/Geometry/#MartaCT.FanBeam.fan2para-Union{Tuple{Interp}, Tuple{T}, Tuple{AbstractArray{T,2},FanBeamGeometry{T,DefaultTomograph}}} where Interp<:Union{MartaCT.Interpolation.NoInterpolation, MartaCT.Interpolation.AbstractInterpolation2D} where T<:Real","page":"Geometry","title":"MartaCT.FanBeam.fan2para","text":"fan2para(\n    sinog_fan::AbstractMatrix{T},\n    fbg::FanBeamGeometry;\n    <keyword arguments>\n) where {T<:Real} -> pbg, sinog_para\n\nConvert given sinogram sinog_fan from fan beam geometry to parallel beam projections.\n\nIt is assumed that the detectors are arranged on a circle arc, not flat.\n\nThe function returns a tuple where fbg is the new geometry with fan beam projections parameters and sinog_fan is the converted sinogram.\n\nArguments\n\nsinog_para: the input sinogram.\npbg: the parallel geometry parameters.\nbackground=nothing: background value to be used, defaults to 0.\ninterpolation: interpolation strategy; it should be a function   taking a matrix as input and returning a function of the indices to   get the interpolated value. By default it is a bilinear interpolation.\n\nSee Also: para2fan\n\n\n\n\n\n","category":"method"},{"location":"api/Geometry/#MartaCT.FanBeam.para2fan-Union{Tuple{Interp}, Tuple{T}, Tuple{AbstractArray{T,2},FanBeamGeometry}} where Interp<:Union{MartaCT.Interpolation.NoInterpolation, MartaCT.Interpolation.AbstractInterpolation2D} where T<:Real","page":"Geometry","title":"MartaCT.FanBeam.para2fan","text":"para2fan(\n    sinog_para::AbstractMatrix{T},\n    fbg::FanBeamGeometry;\n    <keyword arguments>\n) where {T<:Real} -> fbg, sinog_fan\n\nConvert given sinogram sinog_para from parallel beam geometry to fan beam projections.\n\nThe function returns a tuple where fbg is the new geometry with fan beam projections parameters and sinog_fan is the converted sinogram.\n\nArguments\n\nsinog_para: the input sinogram.\npbg: the geometry parameters.\nD: focal spot to ISO distance.\nD′=nothing: focal spot to detectors distance; if not specified   and also γ is not specified, is defined so that the total   fan angle is 1 radian.\nγ=nothing: total fan angle in degrees.\nδ=1: detectors spacing (cell size).\nbackground=nothing: background value to be used, defaults to 0.\ninterpolation: interpolation strategy; it should be a function   taking a matrix as input and returning a function of the indices to   get the interpolated value. By default it is a bilinear interpolation.\n\nSee Also: fan2para\n\n\n\n\n\n","category":"method"},{"location":"GeneralIndex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"GeneralIndex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"api/CTIO/#Input/Output-functions","page":"Input/Output functions","title":"Input/Output functions","text":"","category":"section"},{"location":"api/CTIO/","page":"Input/Output functions","title":"Input/Output functions","text":"Modules = [MartaCT.CTIO]","category":"page"},{"location":"api/CTIO/#MartaCT.CTIO.load_image-Union{Tuple{AbstractString}, Tuple{T}, Tuple{AbstractString,Type{T}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.load_image","text":"load_image(f::AbstractString[, T=Float32]; <keyword arguments>) where {T<:Real}\n\nLoad image from file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.load_image-Union{Tuple{IO}, Tuple{T}, Tuple{IO,Type{T}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.load_image","text":"load_image(io::IO[, T=Float32]; <keyword arguments>) where {T<:Real}\n\nLoad image from stream io.\n\nArguments\n\nio: the stream where to load the image from.\nheader=false: specify if the file contains the header.\nnϕ=0: number of projections (rows in the file for row major ordering).\nnd=0: number of detectors (columns in the file for row major ordering).\nrow_major=false: tells if the data is stored in row major ordering or not.\nheader_type=Int64: the type of the header data.\n\nSee Also: write_image, read_ct_image, write_ct_image\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.load_sinogram-Union{Tuple{AbstractString}, Tuple{T}, Tuple{AbstractString,Type{T}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.load_sinogram","text":"load_sinogram(f::AbstractString[, T=Float32]; <keyword arguments>) where {T<:Real}\n\nLoad sinogram from file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.load_sinogram-Union{Tuple{IO}, Tuple{T}, Tuple{IO,Type{T}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.load_sinogram","text":"load_sinogram(io::IO[, ::Type{T}=Float32]; <keyword arguments>) where {T<:Real}\n\nLoad sinogram from stream io.\n\nThis function is specifically designed to load a sinogram. Do not expect consistent result with other type of images. Use more general function instead, refer to the See Also section.\n\nArguments\n\nio: the stream where to load the image from.\nheader=false: specify if the file contains the header.\nnϕ=0: number of projections (rows in the file for row major ordering).\nnd=0: number of detectors (columns in the file for row major ordering).\nrow_major=false: tells if the data is stored in row major ordering or not.\nheader_type=Int64: the type of the header data.\n\nSee Also: write_sinogram, read_ct_image, write_ct_image\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.load_tomogram-Union{Tuple{AbstractString}, Tuple{T}, Tuple{AbstractString,Type{T}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.load_tomogram","text":"load_tomogram(f::AbstractString[, T=Float32]; <keyword arguments>) where {T<:Real}\n\nLoad reconstructed image from file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.load_tomogram-Union{Tuple{IO}, Tuple{T}, Tuple{IO,Type{T}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.load_tomogram","text":"load_tomogram(io::IO[, T=Float32]; <keyword arguments>) where {T<:Real}\n\nLoad reconstructed image from stream io.\n\nThis function is specifically designed to load a tomogram. Do not expect consistent result with other type of images. Use more general function instead, refer to the See Also section.\n\nArguments\n\nio: the stream where to load the image from.\nheader=false: specify if the file contains the header.\nnϕ=0: number of projections (rows in the file for row major ordering).\nnd=0: number of detectors (columns in the file for row major ordering).\nrow_major=false: tells if the data is stored in row major ordering or not.\nheader_type=Int64: the type of the header data.\n\nSee Also: write_tomogram, read_ct_image, write_ct_image\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.read_ct_image-Union{Tuple{AbstractString}, Tuple{T}, Tuple{AbstractString,Type{T}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.read_ct_image","text":"read_ct_image(f::AbstractString[, T=Float32]; <keyword arguments>) where {T<:Real}\n\nRead CT image from file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.read_ct_image-Union{Tuple{IO}, Tuple{T}, Tuple{IO,Type{T}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.read_ct_image","text":"read_ct_image(io::IO[, T=Float32]; kwargs...) where {T<:Real}\n\nRead CT image from the stream io.\n\nKeyword arguments\n\nheader: read rows and columns from header in the file. [default: false]\nrows: the image rows.\ncols: the image columns.\b\nheader_type: type for the two values of the header. [default: Int64]\nrow_major: assume the image is stored in row major ordering.\n\nSee also: write_ct_image\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.write_ct_image-Union{Tuple{T}, Tuple{AbstractString,AbstractArray{T,2}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.write_ct_image","text":"write_ct_image(f::AbstractString, image::AbstractMatrix{T}; <keyword arguments>) where {T<:Real}\n\nWrite CT image to file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.write_ct_image-Union{Tuple{T}, Tuple{IO,AbstractArray{T,2}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.write_ct_image","text":"write_ct_image(io::IO, image::AbstractMatrix{T}; kwargs...) where {T<:Real}\n\nWrite CT image to the stream io.\n\nKeyword arguments\n\nheader: if true, write header information with rows and columns. [default: false]\nheader_type: type for the two values of the header. [default: Int64]\nrow_major: write image in row major ordering.\n\nSee also: read_ct_image\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.write_image-Union{Tuple{T}, Tuple{AbstractString,AbstractArray{T,2}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.write_image","text":"write_image(f::AbstractString, image::AbstractMatrix{T}; <keyword arguments>) where {T<:Real}\n\nWrite input image to file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.write_image-Union{Tuple{T}, Tuple{IO,AbstractArray{T,2}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.write_image","text":"write_image(io::IO, image::AbstractMatrix{T}; <keyword arguments>) where {T<:Real}\n\nWrite input image to stream io.\n\nArguments\n\nio: the stream where the image should be written to.\nimage: the image data matrix.\nheader: specify if the image header should be written.\nrow_major: specify if the image should be stored in row major order.\nheader_type=Int64: the type of the header data.\n\nSee Also: read_image, write_ct_image, read_ct_image.\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.write_sinogram-Union{Tuple{T}, Tuple{AbstractString,AbstractArray{T,2}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.write_sinogram","text":"write_sinogram(f::AbstractString, sinog::AbstractMatrix{T}) where {T<:Real}\n\nWrite sinogram to file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.write_sinogram-Union{Tuple{T}, Tuple{IO,AbstractArray{T,2}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.write_sinogram","text":"write_sinogram(io::IO, sinog::AbstractMatrix{T}; <keyword arguments>) where {T<:Real}\n\nWrite sinogram sinog to stream io.\n\nThis function is specifically designed to deal with a sinogram image.\n\nArguments\n\nio: the stream where to load the image from.\nheader=false: specify if the file contains the header.\nrow_major=false: tells if the data is stored in row major ordering or not.\nheader_type=Int64: the type of the header data.\n\nSee Also: load_sinogram, read_ct_image, write_ct_image.\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.write_tomogram-Union{Tuple{T}, Tuple{AbstractString,AbstractArray{T,2}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.write_tomogram","text":"write_tomogram(f::AbstractString, tomog::AbstractMatrix{T}; <keyword arguments>) where {T<:Real}\n\nWrite reconstructed image to file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTIO/#MartaCT.CTIO.write_tomogram-Union{Tuple{T}, Tuple{IO,AbstractArray{T,2}}} where T<:Real","page":"Input/Output functions","title":"MartaCT.CTIO.write_tomogram","text":"write_tomogram(io::IO, tomog::AbstractMatrix{T}; <keyword arguments>) where {T<:Real})\n\nWrite reconstructed image to stream io.\n\nArguments\n\nio: the stream where to load the image from.\nheader=false: specify if the file contains the header.\nrow_major=false: tells if the data is stored in row major ordering or not.\nheader_type=Int64: the type of the header data.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#CT-Scan-abstraction","page":"CT Scan abstraction","title":"CT Scan abstraction","text":"","category":"section"},{"location":"api/CTScan/","page":"CT Scan abstraction","title":"CT Scan abstraction","text":"Modules = [MartaCT.CTScan, MartaCT.CTScan.CTImageData]","category":"page"},{"location":"api/CTScan/#MartaCT.CTScan.AbstractCTScanner","page":"CT Scan abstraction","title":"MartaCT.CTScan.AbstractCTScanner","text":"abstract type AbstractCTScanner{<:AbstractArray,<:AbstractGeometry} end\n\nAbstract type for tests in this suite.\n\n\n\n\n\n","category":"type"},{"location":"api/CTScan/#MartaCT.CTScan.FBPScanner-Tuple{AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTScan.FBPScanner","text":"FBPScanner(gst::AbstractCTScanner; name::Optional{String}, study_id::Optional{String})\n\nConstruct a FBPScanner object from another AbstractCTScanner object. This allows to reuse data.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTScan.FBPScanner-Tuple{AbstractGeometry,AbstractTestImage}","page":"CT Scan abstraction","title":"MartaCT.CTScan.FBPScanner","text":"FBPScanner(\n    geometry::AbstractGeometry,\n    image::AbstractTestImage;\n    name::Optional{String},\n    study_id::Optional{String}\n)\n\nConstruct a FBPScanner object.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTScan.FBPScanner-Tuple{AbstractTestImage}","page":"CT Scan abstraction","title":"MartaCT.CTScan.FBPScanner","text":"FBPScanner(\n    image::AbstractTestImage;\n    name::Optional{String},\n    study_id::Optional{String}\n)\n\nConstruct a FBPScanner object.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTScan.FBPScanner-Union{Tuple{D}, Tuple{G}, Tuple{G,D}} where D<:MartaCT.CTScan.CTImageData.AbstractCTData where G<:AbstractGeometry","page":"CT Scan abstraction","title":"MartaCT.CTScan.FBPScanner","text":"FBPScanner(\n    geometry::AbstractGeometry,\n    data::AbstractCTData;\n    name::Optional{String},\n    study_id::Optional{String}\n)\n\nConstruct a FBPScanner object.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.AbstractAlgorithms.project_image-Union{Tuple{AbstractCTScanner}, Tuple{A}, Tuple{AbstractCTScanner,Union{Nothing, A}}} where A<:AbstractProjectionAlgorithm","page":"CT Scan abstraction","title":"MartaCT.AbstractAlgorithms.project_image","text":"project_image(gst::AbstractCTScanner, alg::Optional{A}; <keyword arguments>)\n    where {A <: AbstractProjectionAlgorithm}\n\nCompute sinogram for the test gst.\n\nKeyword arguments depend on the algorithm employed, please see the relative documentation.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.AbstractAlgorithms.reconstruct_image-Tuple{AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.AbstractAlgorithms.reconstruct_image","text":"reconstruct_image(gst::AbstractCTScanner; <keyword arguments>)\n\nReconstruct CT image from test gst.\n\nKeyword arguments depend on the specific algorithm used, please see the relative documentation.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTIO.load_image-Tuple{AbstractString,AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTIO.load_image","text":"load_image(f::AbstractString, gst::AbstractCTScanner)\n\nLoad image from file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTIO.load_image-Tuple{IO,AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTIO.load_image","text":"load_image(io::IO, gst::AbstractCTScanner)\n\nLoad image from stream io.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTIO.load_sinogram-Tuple{AbstractString,AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTIO.load_sinogram","text":"load_sinogram(f::AbstractString, gst::AbstractCTScanner)\n\nLoad sinogram from file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTIO.load_sinogram-Tuple{IO,AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTIO.load_sinogram","text":"load_sinogram(io::IO, gst::AbstractCTScanner)\n\nLoad sinogram from stream io.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTIO.load_tomogram-Tuple{AbstractString,AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTIO.load_tomogram","text":"load_tomogram(f::AbstractString, gst::AbstractCTScanner)\n\nLoad tomogram from file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTIO.load_tomogram-Tuple{IO,AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTIO.load_tomogram","text":"load_tomogram(io::IO, gst::AbstractCTScanner)\n\nLoad tomogram from stream io.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTIO.write_image-Tuple{AbstractString,AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTIO.write_image","text":"write_image(f::AbstractString, gst::AbstractCTScanner)\n\nWrite input image to file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTIO.write_image-Tuple{IO,AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTIO.write_image","text":"write_image(io::IO, gst::AbstractCTScanner)\n\nWrite input image to stream io.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTIO.write_sinogram-Tuple{AbstractString,AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTIO.write_sinogram","text":"write_sinogram(f::AbstractString, gst::AbstractCTScanner)\n\nWrite sinogram to file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTIO.write_sinogram-Tuple{IO,AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTIO.write_sinogram","text":"write_sinogram(io::IO, gst::AbstractCTScanner)\n\nWrite sinogram to stream io.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTIO.write_tomogram-Tuple{AbstractString,AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTIO.write_tomogram","text":"write_tomogram(f::AbstractString, gst::AbstractCTScanner)\n\nWrite tomogram to file f.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTIO.write_tomogram-Tuple{IO,AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTIO.write_tomogram","text":"write_tomogram(io::IO, gst::AbstractCTScanner)\n\nWrite reconstructed image to stream io.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTScan.compute_gray_scale-Tuple{AbstractArray{T,2} where T,ImageParams}","page":"CT Scan abstraction","title":"MartaCT.CTScan.compute_gray_scale","text":"compute_gray_scale(image::AbstractMatrix, imp::ImageParams; mean = false)\n\nCompute the corresponding gray scale for the test image image.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTScan.compute_gray_scale-Tuple{AbstractCTScanner,AbstractGrayScale}","page":"CT Scan abstraction","title":"MartaCT.CTScan.compute_gray_scale","text":"compute_gray_scale(gst::AbstractCTScanner, imp::ImageParams; mean = false)\n\nCompute the corresponding gray scale for the reconstructed image.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTScan.create_image!-Tuple{AbstractCTScanner,ImageParams}","page":"CT Scan abstraction","title":"MartaCT.CTScan.create_image!","text":"create_image!(gst::AbstractCTScanner, par::ImageParams)\n\nCreate gray scale image for the test gst.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTScan.sample_sinogram-Tuple{AbstractCTScanner}","page":"CT Scan abstraction","title":"MartaCT.CTScan.sample_sinogram","text":"sample_sinogram(gst::AbstractCTScanner; <keyword arguments>)\n\nReturns a new test object with the resampled sinogram.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CalibrationBase.calibrate_image-Union{Tuple{AbstractCTScanner}, Tuple{T}} where T<:Real","page":"CT Scan abstraction","title":"MartaCT.CalibrationBase.calibrate_image","text":"calibrate_image(gst::AbstractCTScanner; min_pos, max_pos, interval=0..1, window=nothing)\n\nPerform calibration of input image with reference values.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CalibrationBase.calibrate_image-Union{Tuple{U}, Tuple{T}, Tuple{AbstractCTScanner,AbstractImageParams}} where U<:Real where T<:Real","page":"CT Scan abstraction","title":"MartaCT.CalibrationBase.calibrate_image","text":"calibrate_image(gst::AbstractCTScanner, imp::ImageParams; interval=nothing, window=nothing)\n\nPerform calibration of input image using image parameters as reference.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CalibrationBase.calibrate_tomogram-Union{Tuple{AbstractCTScanner}, Tuple{T}} where T<:Real","page":"CT Scan abstraction","title":"MartaCT.CalibrationBase.calibrate_tomogram","text":"calibrate_tomogram(gst::AbstractCTScanner; min_pos, max_pos, interval=0..1, window=nothing)\n\nPerform calibration of reconstructed image with reference values.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CalibrationBase.calibrate_tomogram-Union{Tuple{U}, Tuple{T}, Tuple{AbstractCTScanner,AbstractImageParams}} where U<:Real where T<:Real","page":"CT Scan abstraction","title":"MartaCT.CalibrationBase.calibrate_tomogram","text":"calibrate_tomogram(gst::AbstractCTScanner, imp::ImageParams; interval=nothing, window=nothing)\n\nPerform calibration of reconstructed image using image parameters as reference.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTScan.CTImageData.CTData","page":"CT Scan abstraction","title":"MartaCT.CTScan.CTImageData.CTData","text":"mutable struct CTData{M}\n\nHold data for reconstruction. M should be a subtype of AbstractArray, for example Matrix{Float32} or AFMatrix{Float64}. By default, the library will use CPU objects rather than GPU ones.\n\n\n\n\n\n","category":"type"},{"location":"api/CTScan/#MartaCT.CTScan.CTImageData.CTData-Tuple{CTImage}","page":"CT Scan abstraction","title":"MartaCT.CTScan.CTImageData.CTData","text":"CTData(::AbstractCTImage)\n\nConstruct a CTData object from its constituents.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTScan.CTImageData.CTData-Union{Tuple{Type{M}}, Tuple{M}} where M<:(AbstractArray{var\"#s94\",N} where N where var\"#s94\"<:Number)","page":"CT Scan abstraction","title":"MartaCT.CTScan.CTImageData.CTData","text":"CTData(::Type{M}) where {M<:AbstractArray{<:Number}}\n\nConstruct an empty CTData object.\n\n\n\n\n\n","category":"method"},{"location":"api/CTScan/#MartaCT.CTScan.CTImageData.CTData-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"CT Scan abstraction","title":"MartaCT.CTScan.CTImageData.CTData","text":"CTData([::Type{T} = Float32]) where {T<:Number}\n\nConstruct an empty CTData object with eltype T.\n\n\n\n\n\n","category":"method"},{"location":"api/CTPlots/#CT-Plots","page":"CT Plots","title":"CT Plots","text":"","category":"section"},{"location":"api/CTPlots/","page":"CT Plots","title":"CT Plots","text":"Modules = [MartaCT.CTPlots]","category":"page"},{"location":"api/CTPlots/#MartaCT.CTPlots.plot_gray_scale-Tuple{ImageParams,Vararg{AbstractArray{T,1} where T,N} where N}","page":"CT Plots","title":"MartaCT.CTPlots.plot_gray_scale","text":"plot_gray_scale(\n    imp::ImageParams,\n    gray_scale_data...;\n    options = nothing,\n    <keyword arguments>\n)\n\nPlot gray scale data.\n\nAdditional keyword arguments are passed to the Plots library.\n\n\n\n\n\n","category":"method"},{"location":"api/CTPlots/#MartaCT.CTPlots.plot_image-Tuple{AbstractCTScanner}","page":"CT Plots","title":"MartaCT.CTPlots.plot_image","text":"plot_image(gst::AbstractCTScanner)\n\nPlot input image created for the test gst.\n\n\n\n\n\n","category":"method"},{"location":"api/CTPlots/#MartaCT.CTPlots.plot_image-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T","page":"CT Plots","title":"MartaCT.CTPlots.plot_image","text":"plot_image(image::AbstractMatrix{T}; <keyword arguments>) where {T}\n\nPlot CT image image with predefined options.\n\nAdditional keyword arguments are passed to the Plots library functions.\n\nSee also: plot_sinogram, plot_tomogram\n\n\n\n\n\n","category":"method"},{"location":"api/CTPlots/#MartaCT.CTPlots.plot_sinogram-Tuple{AbstractCTScanner}","page":"CT Plots","title":"MartaCT.CTPlots.plot_sinogram","text":"plot_sinogram(gst::AbstractCTScanner)\n\nPlot the sinogram computed for the test gst.\n\n\n\n\n\n","category":"method"},{"location":"api/CTPlots/#MartaCT.CTPlots.plot_sinogram-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T","page":"CT Plots","title":"MartaCT.CTPlots.plot_sinogram","text":"plot_sinogram(sinog::AbstractMatrix{T}; <keyword arguments>) where {T}\n\nPlot sinogram sinog with predefined options.\n\nAdditional keyword arguments are passed to the underlying plotting driver.\n\nSee also: plot_image, plot_tomogram\n\n\n\n\n\n","category":"method"},{"location":"api/CTPlots/#MartaCT.CTPlots.plot_tomogram-Tuple{AbstractCTScanner}","page":"CT Plots","title":"MartaCT.CTPlots.plot_tomogram","text":"plot_tomogram(gst::AbstractCTScanner)\n\nPlot the reconstructed image for the test gst.\n\n\n\n\n\n","category":"method"},{"location":"api/CTPlots/#MartaCT.CTPlots.plot_tomogram-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T","page":"CT Plots","title":"MartaCT.CTPlots.plot_tomogram","text":"plot_tomogram(tomog::AbstractMatrix{T}; <keyword arguments>) where {T}\n\nPlot reconstructed CT image tomog with predefined options.\n\nAlias for plot_image. See plot_image for full reference. Additional keyword arguments are passed to the Plots library.\n\nSee also: plot_sinogram, plot_image\n\n\n\n\n\n","category":"method"},{"location":"api/Calibration/#Calibration","page":"Calibration","title":"Calibration","text":"","category":"section"},{"location":"api/Calibration/","page":"Calibration","title":"Calibration","text":"Modules = [MartaCT.CalibrationBase, MartaCT.Calibration]","category":"page"},{"location":"api/Calibration/#MartaCT.CalibrationBase.calibrate_image!-Union{Tuple{AbstractArray{T,2}}, Tuple{U}, Tuple{T}} where U<:Real where T<:Real","page":"Calibration","title":"MartaCT.CalibrationBase.calibrate_image!","text":"calibrate_image!(image::AbstractMatrix{T}; min_pos, max_pos, interval=0..1, window=nothing) where {T<:Real}\n\nPerform calibration of image with reference values.\n\n\n\n\n\n","category":"method"},{"location":"api/Calibration/#MartaCT.CalibrationBase.calibrate_image!-Union{Tuple{W}, Tuple{U}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractImageParams}} where W<:Real where U<:Real where T<:Real","page":"Calibration","title":"MartaCT.CalibrationBase.calibrate_image!","text":"calibrate_image!(image::AbstractMatrix{T}, imp::AbstractImageParams; interval=nothing, window=nothing) where {T<:Real}\n\nPerform calibration of image using image parameters as reference.\n\n\n\n\n\n","category":"method"},{"location":"api/Calibration/#MartaCT.CalibrationBase.calibrate_image-Union{Tuple{AbstractArray{T,2}}, Tuple{U}, Tuple{T}} where U<:Real where T<:Real","page":"Calibration","title":"MartaCT.CalibrationBase.calibrate_image","text":"calibrate_image(image::AbstractMatrix{T}; min_pos, max_pos, interval=0..1, window=nothing) where {T<:Real}\n\nPerform calibration of image with reference values.\n\n\n\n\n\n","category":"method"},{"location":"api/Calibration/#MartaCT.CalibrationBase.calibrate_image-Union{Tuple{W}, Tuple{U}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractImageParams}} where W<:Real where U<:Real where T<:Real","page":"Calibration","title":"MartaCT.CalibrationBase.calibrate_image","text":"calibrate_image(image::AbstractMatrix{T}, imp::AbstractImageParams; interval=nothing, window=nothing) where {T<:Real}\n\nPerform calibration of image using image parameters as reference.\n\n\n\n\n\n","category":"method"},{"location":"api/Calibration/#MartaCT.CalibrationBase.calibrate_tomogram!-Union{Tuple{AbstractArray{T,2}}, Tuple{U}, Tuple{T}} where U<:Real where T<:Real","page":"Calibration","title":"MartaCT.CalibrationBase.calibrate_tomogram!","text":"calibrate_tomogram(image::AbstractMatrix{T}; min_pos, max_pos, interval=0..1, window=nothing) where {T<:Real}\n\nPerform calibration of reconstructed image with reference values.\n\n\n\n\n\n","category":"method"},{"location":"api/Calibration/#MartaCT.CalibrationBase.calibrate_tomogram!-Union{Tuple{W}, Tuple{U}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractImageParams}} where W<:Real where U<:Real where T<:Real","page":"Calibration","title":"MartaCT.CalibrationBase.calibrate_tomogram!","text":"calibrate_tomogram!(image::AbstractMatrix{T}, imp::AbstractImageParams; interval=nothing, window=nothing) where {T<:Real}\n\nPerform calibration of reconstructed image with image parameters as reference.\n\n\n\n\n\n","category":"method"},{"location":"api/Calibration/#MartaCT.CalibrationBase.calibrate_tomogram-Union{Tuple{AbstractArray{T,2}}, Tuple{U}, Tuple{T}} where U<:Real where T<:Real","page":"Calibration","title":"MartaCT.CalibrationBase.calibrate_tomogram","text":"calibrate_tomogram(image::AbstractMatrix{T}; min_pos, max_pos, interval=0..1, window=nothing) where {T<:Real}\n\nPerform calibration of reconstructed image with reference values.\n\n\n\n\n\n","category":"method"},{"location":"api/Calibration/#MartaCT.CalibrationBase.calibrate_tomogram-Union{Tuple{W}, Tuple{U}, Tuple{T}, Tuple{AbstractArray{T,2},AbstractImageParams}} where W<:Real where U<:Real where T<:Real","page":"Calibration","title":"MartaCT.CalibrationBase.calibrate_tomogram","text":"calibrate_tomogram(image::AbstractMatrix{T}, imp::AbstractImageParams; interval=nothing, window=nothing) where {T<:Real}\n\nPerform calibration of reconstructed image with image parameters as reference.\n\n\n\n\n\n","category":"method"},{"location":"api/CTImages/#CTImages","page":"CTImages","title":"CTImages","text":"","category":"section"},{"location":"api/CTImages/","page":"CTImages","title":"CTImages","text":"Modules = [MartaCT.CTImages]","category":"page"},{"location":"api/CTImages/#MartaCT.CTImages.rescale!-Union{Tuple{AbstractArray{T,N} where N}, Tuple{W}, Tuple{U}, Tuple{T}} where W<:Number where U<:Number where T<:Number","page":"CTImages","title":"MartaCT.CTImages.rescale!","text":"rescale!(x::AbstractArray;\n    interval=nothing, calibration=nothing, window=nothing)\n\nRescale array x to the interval specified by interval.\n\nIf calibration is not nothing, then rescaling is done with reference to the values given by calibration. In other words, minimum and maximum are assumed to be the values specified by calibration.\n\nSee also: rescale\n\n\n\n\n\n","category":"method"},{"location":"api/CTImages/#MartaCT.CTImages.rescale!-Union{Tuple{U}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Number,Number}} where U<:Number where T<:Number","page":"CTImages","title":"MartaCT.CTImages.rescale!","text":"rescale!(x::AbstractArray, slope::Number, intercept::Number)\n\nIn place linear rescaling of x.\n\nSee also: rescale\n\n\n\n\n\n","category":"method"},{"location":"api/CTImages/#MartaCT.CTImages.rescale-Tuple{AbstractArray}","page":"CTImages","title":"MartaCT.CTImages.rescale","text":"rescale(x::AbstractArray;\n    interval=nothing, calibration=nothing, window=nothing)\n\nRescale array x to the interval specified by interval.\n\nIf calibration is not nothing, then rescaling is done with reference to the values given by calibration. In other words, minimum and maximum are assumed to be the values specified by calibration.\n\nSee also: rescale!\n\n\n\n\n\n","category":"method"},{"location":"api/CTImages/#MartaCT.CTImages.rescale-Union{Tuple{U}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Number,Number}} where U<:Number where T<:Number","page":"CTImages","title":"MartaCT.CTImages.rescale","text":"rescale(x::AbstractArray, slope::Number, intercept::Number; window)\n\nLinear rescaling of x as x * slope + intercept.\n\nSee also: rescale!\n\n\n\n\n\n","category":"method"},{"location":"api/CTImages/#MartaCT.CTImages.rotate-Union{Tuple{Interp}, Tuple{T}, Tuple{AbstractArray{T,2},Real}} where Interp<:Union{MartaCT.Interpolation.NoInterpolation, MartaCT.Interpolation.AbstractInterpolation2D} where T<:Number","page":"CTImages","title":"MartaCT.CTImages.rotate","text":"rotate(mat::AbstractMatrix, α::Real; <keyword arguments>)\n\nRotate matrix mat about the center of angle α given in degrees. If rows and cols are not given, the rotated matrix has the same dimensions of the original matrix.\n\nArguments\n\nmat: matrix to rotate.\nα: angle in degrees.\nrows=nothing: number of rows of the rotated matrix.\ncols=nothing: number of columns of the rotated matrix.\ninterpolation: interpolation strategy. By default is   BilinearInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/Utils/#Utilities-for-MartaCT","page":"Utilities for MartaCT","title":"Utilities for MartaCT","text":"","category":"section"},{"location":"api/Utils/","page":"Utilities for MartaCT","title":"Utilities for MartaCT","text":"Modules = [MartaCT.Utils, MartaCT.TypeDict]","category":"page"},{"location":"#MartaCT","page":"Home","title":"MartaCT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CT images reconstruction and analysis","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for image reconstruction. The main field of application for this package is medical imaging, but it can also serve as a base for Quantum Tomography applications.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"Installation.md\",\n  \"Tutorial.md\",\n  \"QuantumOptics.md\",\n  \"GeneralIndex.md\",\n]","category":"page"},{"location":"Installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"Installation/","page":"Installation","title":"Installation","text":"MartaCT can be installed with the following commands:","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.add(url=\"https://gitlab.com/homodyne-ct/MartaCT.jl.git\")","category":"page"}]
}
